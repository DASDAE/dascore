---
title: Processing
execute:
  warning: false
---
The following shows some simple examples of patch processing. See the
[proc module documentation](`dascore.proc`) for a list of processing functions.

# Decimate

The [decimate patch function](`dascore.Patch.decimate`) decimates a `Patch`
along a given axis while by default performing low-pass filtering to avoid
[aliasing](https://en.wikipedia.org/wiki/Aliasing).

## Data creation

First, we create a patch composed of two sine waves; one above the new
decimation frequency and one below.

```{python}
import dascore as dc

patch = dc.examples.sin_wave_patch(
    sample_rate=1000,
    frequency=[200, 10],
    channel_count=2,
)
patch.viz.wiggle(show=True);
```

## IIR filter

Next we decimate by 10x using IIR filter

```{python}
decimated_iir = patch.decimate(time=10, filter_type='iir')
decimated_iir.viz.wiggle(show=True);
```

Notice the lowpass filter removed the 200 Hz signal and only
the 10Hz wave remains.

## FIR filter

Next we decimate by 10x using FIR filter.

```{python}
decimated_fir = patch.decimate(time=10, filter_type='fir')
decimated_fir.viz.wiggle(show=True);
```

## No Filter

Next, we decimate without a filter to purposely induce aliasing.

```{python}
decimated_no_filt = patch.decimate(time=10, filter_type=None)
decimated_no_filt.viz.wiggle(show=True);
```

# Taper

The [taper function](`dascore.Patch.taper`) is used to gently taper the edges of
a patch dimension to zero. To see this, let's create a patch of all 1s and apply
the taper function

```{python}
import numpy as np
import dascore as dc

_patch = dc.get_example_patch()
patch_ones = _patch.new(data=np.ones_like(_patch.data))
```

The following code will apply a 10% taper, meaning the first and last 10% of the
samples, along the time dimension.

```{python}
patch_ones.taper(time=0.1).viz.waterfall();
```

Of course, any dimensions works, and passing a tuple of values enables
different amounts of tapering for each end of the dimension.


```{python}
patch_ones.taper(distance=(0.1, 0.3)).viz.waterfall();
```

Either end can also be `None` to indicated tapering on a single side of the patch
dimension.

```{python}
patch_ones.taper(distance=(None, 0.1)).viz.waterfall();
```


## Managing Edge Effects
One of the main applications of tapering is to mitigate edge artefacts, or "edge effects"
associated with several other types of processing, including filtering. Consider the
following:

### Bandpass filtering without tapering

```{python}
import dascore as dc

patch = (
    dc.get_example_patch('example_event_1')
    .pass_filter(time=(None, 300))
)

patch.viz.waterfall(show=True, scale=0.04);

```

### Bandpass filtering with tapering

```{python}
import dascore as dc

patch = (
    dc.get_example_patch('example_event_1')
    .taper(time=0.05)
    .pass_filter(time=(None, 300))
)

patch.viz.waterfall(show=True, scale=0.15);
```
