---
title: Patch
execute:
  warning: false
---

A [`Patch`](`dascore.core.patch.Patch`) manages data and its associated coordinates and metadata.

:::{.callout-note}
The `Patch` design was inspired by [Xarray's `DataArray` object](https://docs.xarray.dev/en/stable/generated/xarray.DataArray.html)
:::

# Creating Patches

Patches can be created in a few ways.

## Load an Example Patch

DASCore includes several example datasets. They are mostly used for simple demonstrations and testing.

```{python}
import dascore as dc
from dascore import print

pa1 = dc.get_example_patch("random_das")
pa2 = dc.get_example_patch("example_event_1")
```

## Load a File

We first download a small example fiber file from a URL in the DASCore library (you need an internet connection). Next, we read it into a [spool](`dascore.core.spool.BaseSpool`) object then get the first (and only) patch. Spools are covered in more detail in the [next section](spool.qmd).

```{python}
import dascore as dc
from dascore.utils.downloader import fetch

path = fetch("terra15_das_1_trimmed.hdf5")  # path to a datafile

pa = dc.spool(path)[0]
```

## Create a Patch from Scratch

Patches can be created from using:

- A data array
- Coordinates for labeling each axis
- Attributes (optional)

```{python}
import numpy as np

import dascore as dc
from dascore.utils.time import to_timedelta64

# Create the patch data
array = np.random.random(size=(300, 2_000))

# Create attributes, or metadata
t1 = np.datetime64("2017-09-18")
attrs = dict(
    d_distance=1,
    d_time=to_timedelta64(1 / 250),
    category="DAS",
    id="test_data1",
    time_min=t1,
    data_units="um/(m * s)"
)

# Create coordinates, labels for each axis in the array.
coords = dict(
    distance=np.arange(array.shape[0]) * attrs["d_distance"],
    time=t1 + np.arange(array.shape[1]) * attrs["d_time"],
)

# define dimensions (first label corresponds to data axis 0)
dims = ('distance', 'time')

pa = dc.Patch(data=array, coords=coords, attrs=attrs, dims=dims)
```

# Patch Anatomy

## Data

The data is simply an n-dimensional array which is accessed with the `data` attribute.

```{python}
import dascore as dc

patch = dc.get_example_patch()

print(f"Data shape is {patch.data.shape}")

print(f"Data contents are\n{patch.data}")
```

:::{.callout-note}
The data arrays are should be read-only. This means you can't modify them, but should first make a copy.

```python
import numpy as np

patch.data[:10] = 12  # wont work

array = np.array(patch.data)  # this makes a copy
array[:10] = 12  # then this works
```
:::


## Coords

DASCore implements a special class, called a [CoordinateManager](`dascore.core.coordmanager.CoordManager`), which managers dimension names, coordinate labels, etc. This class behaves like a dict, so coordinate arrays are easily accessed via their names.

```{python}
import dascore as dc

patch = dc.get_example_patch()

coords = patch.coords

# get time array
time = coords['time']

# get distance array
distance = coords['distance']
```

Coords also have a useful string representation:

```{python}
print(coords)
```

You can read more about the coordinate manager in [its doc page](`dascore.core.coordmanager`).

## Attrs

The metadata stored in `Patch.attrs` is a [pydnatic model](https://docs.pydantic.dev/usage/models/) which enforces some basic schema validation. You can print the schema info like this:

```python
import dascore as dc

print(dc.PatchAttrs.__doc__)
```

There may also be other attributes added by specific fiber formats.

## String Rep.

DASCore Patches have as useful string representation:

```{python}
import dascore as dc

patch = dc.get_example_patch()
print(patch)
```

:::{callout-note}
For various reasons, Patches should be treated as *immutable*, meaning they should not be modified in place, but rather new patches are created when something needs to be modified.
:::

# Selecting (trimming)

Patches are trimmed using the [`select`](`dascore.Patch.select`) method.  `select` takes the coordinate name and a tuple of (lower_limit, upper_limit) as the values. Either limit can be `None` or `...` indicating an open interval.

```{python}
import numpy as np

import dascore as dc

patch = dc.get_example_patch()
attrs = patch.attrs

# select 1 sec after current start time to 1 sec before end time.
one_sec = dc.to_timedelta64(1)
select_tuple = (attrs.time_min + one_sec, attrs.time_max - one_sec)
new = patch.select(time=select_tuple)

# select only the first half of the distance channels.
distance_max = np.mean(patch.coords['distance'])
new = patch.select(distance=(..., distance_max))
```

The "relative" keyword is used to trim coordinates based on start (positive) to end (negative)

```{python}
import dascore as dc
from dascore.units import ft

patch = dc.get_example_patch()

# We can make the example above simpler with relative selection
new = patch.select(time=(1, -1), relative=True)

# select 2 seconds from end to 1 second from end
new = patch.select(time=(-2, -1), relative=True)

# select last 100 ft of distance channels
new = patch.select(distance=(..., -100 * ft), relative=True)
```

# Processing

The patch has several methods which are intended to be chained together via a [fluent interface](https://en.wikipedia.org/wiki/Fluent_interface), meaning each method returns a new `Patch` instance.

```{python}
import dascore as dc
pa = dc.get_example_patch()

out = (
    pa.decimate(time=8)  # decimate to reduce data volume by 8 along time dimension
    .detrend(dim='distance')  # detrend along distance dimension
    .pass_filter(time=(..., 10))  # apply a low-pass 10 Hz butterworth filter
)
```
The processing methods are located in the [dascore.proc](`dascore.proc`) module.

# Visualization

DASCore provides various visualization functions found in the [dascore.viz](`dascore.viz`) package or using the `Patch.viz` namespace. DASCore generally only implements simple, matplotlib based visualizations but other DASDAE packages will do more interesting visualizations.

```{python}
import dascore as dc

patch = (
    dc.get_example_patch('example_event_1')
    .taper(time=0.05)
    .pass_filter(time=(None, 300))
)

patch.viz.waterfall(show=True, scale=0.2);
```

# Modifying Patches

Because patches should be treated as immutable objects, you can't just modify
them with normal item assignment. There are a few methods that return new
patches with modifications, however, that are functionally the same.

## New

Often you may wish to modify one aspect of the patch. [`Patch.new`](`dascore.core.patch.Patch.new`) is designed for this purpose:

```{python}
import dascore as dc
pa = dc.get_example_patch()

# create a copy of patch with new data but coords and attrs stay the same
new = pa.new(data=pa.data * 10)
```

## Update Attrs

[`Patch.update_attrs`](`dascore.core.patch.Patch.update_attrs`) is for making small changes
to the patch attrs (metadata) while keeping the unaffected metadata (`Patch.new` would require
you replace the entirety of attrs).

```{python}
import dascore as dc
pa = dc.get_example_patch()

# update existing attribute 'network' and create new attr 'new_attr'
pa1 = pa.update_attrs(**{'network': 'exp1', 'new_attr': 42})
```

`Patch.update_attrs` also tries to keep the patch attributes consistent.
For example, changing the start, end, or sampling of a dimension should
update the other attributes affected by the change.

```{python}
import dascore as dc
pa = dc.get_example_patch()

# update start time should also shift endtime
pa1 = pa.update_attrs(time_min='2000-01-01')

print(pa.attrs['time_min'])
print(pa1.attrs['time_min'])
```

# Method Chaining

In most cases, you should use method chaining as part of a
[fluent interface](https://en.wikipedia.org/wiki/Fluent_interface) when working with patches.

For example:
```{.python}
import dascore as dc

pa = (
    dc.get_example_patch()  # load the patch
    .pass_filter(time=(1, 10)  # apply bandpass filter
    .detrend(dim='time')  # detrend along time dimension
)
```

Similar to Pandas, `Patch` has a [pipe method](`dascore.core.patch.Patch.pipe`) so non-patch methods
can still be used in a method chain.


```{.python}
import dascore as dc

def func(patch, arg1=1):
    """Example non-patch method"""
    return patch.update_attrs(arg1=1)

pa = (
    dc.get_example_patch()
    .pass_filter(time=(..., 10))
    .detrend('time', 'linear')
    .pipe(func, arg1=3)
)
```

# Adding Coordinates

It is common to have additional coordinates, such as latitude/longitude,  attached to a particular dimension (e.g., distance). There are two ways to add coordinates to a patch:

## Update Coordinates

The [update_coords](`dascore.Patch.update_coords`) method will return a new patch with the coordinate added, if it didn't exist in the original, or replaced, if it did.

```{python}
import numpy as np
import dascore as dc
pa = dc.get_example_patch()
coords = pa.coords
dist = coords['distance']
time = coords['time']

# Add a single coordinate associated with distance dimension
lat = np.arange(0, len(dist)) * .001 -109.857952
out_1 = pa.update_coords(latitude=('distance', lat))

# Add multiple coordinates associated with distance dimension
lon = np.arange(0, len(dist)) *.001 + 41.544654
out_2 = pa.update_coords(
    latitude=('distance', lat),
    longitude=('distance', lon),
)

# Add multi-dimensional coordinates
quality = np.ones_like(pa.data)
out_3 = pa.update_coords(
    quality=(pa.dims, quality)
)
```

## Coords in Patch Initialization

Any number of coordinates can also be assigned when the patch is initiated. For coordinates other than those of the patch dimensions, the associated dimensions must be specified. For example:

```{python}
import dascore as dc
import numpy as np

# create data for patch
rand = np.random.RandomState(13)
array = rand.random(size=(20, 100))
time1 = np.datetime64("2020-01-01")

# create patch attrs
attrs = dict(dx=1, d_time=1 / 250.0, category="DAS", id="test_data1")
time_deltas = dc.to_timedelta64(np.arange(array.shape[1]) * attrs["d_time"])

# create coordinate data
distance = np.arange(array.shape[0]) * attrs["dx"]
time = time1 + time_deltas
quality = np.ones_like(array)
latitude = np.arange(array.shape[0]) * .001 - 111.00

# create coord dict
coords = dict(
    distance=distance,
    time=time,
    latitude=("distance", latitude),  # Note distance is attached dimension
    quality=(("distance", "time"), quality),  # Two attached dimensions here
)

# Define dimensions of array and init Patch
dims = ("distance", "time")
out = dc.Patch(data=array, coords=coords, attrs=attrs, dims=dims)
```

# Patch Operations

Patches implement common operators which means that many [ufunc](https://numpy.org/doc/stable/reference/ufuncs.html) type operations can be applied directly on a patch with built-in python operators.

In the case of scalars and numpy arrays, the operations are broadcast over the patch data. In the case of two patches, compatibility between patches are first checked, the intersection of the coords and attrs are calculated, then the operator is applied to both patchs' data. Here are a few examples:

## Patch operations with scalars

```{python}
import numpy as np

import dascore as dc

patch = dc.get_example_patch()

out1 = patch / 10
assert np.allclose(patch.data / 10, out1.data)

out2 = patch ** 2.3
assert np.allclose(patch.data ** 2.3, out2.data)

out3 = patch - 3
assert np.allclose(patch.data - 3, out3.data)
```

Units are also fully supported.

```{python}
import dascore as dc
from dascore.units import m, s

patch = dc.get_example_patch().set_units("m/s")

# multiplying patches by a quantity with units updates the data_units attribute.
new = patch * 10 * m/s

print(f"units before operation {patch.attrs.data_units}")
print(f"units after operation {new.attrs.data_units}")
```

## Patch operations with numpy arrays

```{python}
import numpy as np

import dascore as dc

patch = dc.get_example_patch()
ones = np.ones(patch.shape)

out1 = patch + ones
assert np.allclose(patch.data + ones, out1.data)
```

Units also work with numpy arrays.

```{python}
import numpy as np

import dascore as dc
from dascore.units import furlongs

patch = dc.get_example_patch()
ones = np.ones(patch.shape) * furlongs

out1 = patch * ones
print(f"units before operation {patch.attrs.data_units}")
print(f"units after operation {out1.attrs.data_units}")
```

## Patch operations with other patches

```{python}
import numpy as np

import dascore as dc
from dascore.units import furlongs

patch = dc.get_example_patch()

# adding two patches together simply adds their data and checks/merges their
# coords and attrs.
out = patch + patch

assert np.allclose(patch.data * 2, out.data)
```

See [`merge_compatible_coords_attrs`](`dascore.utils.patch.merge_compatible_coords_attrs`) for more details on how attributes and coordinates are handled when performing operations on two patches.
