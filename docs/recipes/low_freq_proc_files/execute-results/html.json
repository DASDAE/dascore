{
  "hash": "62d4a9de9b7376fe4f0b7966ce6b85df",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Low-Frequency Processing\"\nexecute:\n  eval: false\n---\n\n\n\n\nThis recipe demonstrates how DASCore can be used to apply low-frequency (LF) processing to a spool of DAS data. LF processing helps efficiently downsample the entire spool.\n\n\n## Get a spool and define parameters \n\n::: {#901a27e6 .cell execution_count=1}\n``` {.python .cell-code}\n## Load libraries and get a spool to work on\nimport numpy as np\n\nimport dascore as dc\n\n\n# Define path for saving results\noutput_data_dir = '/path/to/desired/output/directory/'\n\n# Get a spool to work on\nsp = dc.get_example_spool().update()\n\n# Sort the spool\nsp = sp.sort(\"time\")\n# You may also want to sub-select the spool for the desired distance or time samples before proceeding.\n\n# Get the first patch\npa = sp[0]\n\n# Define the target sampling interval (in sec.)\ndt = 10 \n# With a sampling interval of 10 seconds, the cutoff frequency (Nyquist frequency) is determined to be 0.05 Hz \ncutoff_freq = 1 / (2*dt)\n\n# Safety factor for the low-pass filter to avoid ailiasing \nfilter_safety_factor = 0.9\n\n# Enter memory size to be dedicated for processing (in MB)\nmemory_limit_MB = 10_000\n\n# Define a tolerance for determining edge effects (used in next step)\ntolerance = 1e-3\n```\n:::\n\n\n## Calculate chunk size and determine edge effects\n\nTo chunk the spool, first we need to figure out the chunk size based on machine's memory size so we ensure we can load and process patches with no memory issues. Longer chunk size (longer patches) increases computation efficiency. \n\nNotes: \n\n1. The `processing_factor` is required because certain processing routines involve making copies of the data during the processing steps. It should be determined by performing memory profiling on an example dataset for the specific processing routine. For instance, the combination of low-pass filtering and interpolation, discussed in the next section, requires a processing factor of approximately 5.\n2. The `memory_safety_factor` is optional and helps prevent getting too close to the memory limit.\n\n::: {#9091a872 .cell execution_count=2}\n``` {.python .cell-code}\n# Get patch's number of bytes per seconds (based on patch's data type) \npa_bytes_per_second = pa.data.nbytes / pa.seconds\n# Define processing factor and safety factor \nprocessing_factor = 5  \nmemory_safety_factor = 1.2 \n\n# Calculate memory size required for each second of data to get processed\nmemory_size_per_second = pa_bytes_per_second * processing_factor * memory_safety_factor\nmemory_size_per_second_MB = memory_size_per_second / 1e6\n\n# Calculate chunk size that can be loaded (in seconds)\nchunk_size = memory_limit_MB / memory_size_per_second_MB \n```\n:::\n\n\nNext, we need to determine the extent of artifacts introduced by low-pass filtering at the edges of each patch. To achieve this, we apply LF processing to a delta function patch, which contains a unit value at the center and zeros elsewhere. The distorted edges are then identified based on a defined threshold.\n\n::: {#528298a0 .cell execution_count=3}\n``` {.python .cell-code}\n# Retrieve a patch of appropriate size for LF processing that fits into memory\npa_chunked_sp = sp.chunk(time=chunk_size)[0] \n# Create a delta patch based on new patch size\ndelta_pa = dc.get_example_patch(\"delta_patch\", dim=\"time\", patch=pa_chunked_sp)\n\n# Apply the low-pass filter on the delta patch\ndelta_pa_low_passed = delta_pa.pass_filter(time=(None, cutoff_freq * filter_safety_factor))\n# Resample the low-passed filtered patch\nnew_time_ax = np.arange(delta_pa.attrs[\"time_min\"], delta_pa.attrs[\"time_max\"], np.timedelta64(dt, \"s\"))\ndelta_pa_lfp = delta_pa_low_passed.interpolate(time=new_time_ax)\n\n# Identify the indices where the absolute value of the data exceeds the threshold\ndata_abs = np.abs(delta_pa_lfp.data)\nthreshold = np.max(data_abs) * tolerance\nind = data_abs > threshold\nind_1 = np.where(ind)[1][0]\nind_2 = np.where(ind)[1][-1]\n\n# Get the total duration of the processed delta function patch in seconds\ntime_coord = delta_pa_lfp.get_coord('time')\ndelta_pa_lfp_seconds = dc.to_float((time_coord.max() - time_coord.min()))\n# Convert the new time axis to absolute seconds, relative to the first timestamp\ntime_ax_abs = (new_time_ax - new_time_ax[0]) / np.timedelta64(1, \"s\")\n# Center the time axis \ntime_ax_centered = time_ax_abs - delta_pa_lfp_seconds // 2 \n\n# Calculate the maximum of edges in both sides (in seconds) where artifacts are present\nedge = max(np.abs(time_ax_centered[ind_1]), np.abs(time_ax_centered[ind_2]))\n\n# Validate the `edge` value to ensure sufficient processing patch size\nif np.ceil(edge) >= chunk_size / 2:\n    raise ValueError(\n        f\"The calculated `edge` value ({edge:.2f} seconds) is greater than half of the processing patch size \"\n        f\"({chunk_size:.2f} seconds). To resolve this and increase efficiency, consider one of the following:\\n\"\n        \"- Increase `memory_size` to allow for a larger processing window.\\n\"\n        \"- Increase `tolerance` to reduce the sensitivity of artifact detection.\"\n    )\n```\n:::\n\n\n## Perform low-frequency processing and save results on disk\n\n::: {#bf7477eb .cell execution_count=4}\n``` {.python .cell-code}\n# Helper functions to handle the name of LF processed patches \ndef _format_time_as_string(timestamp: np.datetime64) -> str:\n    \"\"\"\n    Converts a datetime64 object to a formatted string suitable for file naming.\n\n    Args:\n        timestamp (np.datetime64): The timestamp to format.\n\n    Returns:\n        str: A formatted string in 'YYYY-MM-DDTHHMMSS.mmm' format, \n             compatible with Windows file naming.\n    \"\"\"\n    formatted_time = str(timestamp.astype(\"datetime64[ms]\"))[:21]\n    return formatted_time.replace(\":\", \"\")  # Remove colons for Windows compatibility\n\ndef generate_file_name(start_time: np.datetime64, end_time: np.datetime64) -> str:\n    \"\"\"\n    Generates a standardized file name for low-frequency DAS data.\n\n    Args:\n        start_time (np.datetime64): The start time of the data range.\n        end_time (np.datetime64): The end time of the data range.\n\n    Returns:\n        str: A file name in the format 'LFDAS_<start_time>_<end_time>.h5'.\n    \"\"\"\n    start_time_str = _format_time_as_string(start_time)\n    end_time_str = _format_time_as_string(end_time)\n    return f\"LFDAS_{start_time_str}_{end_time_str}.h5\"\n\n\n# First we chunk the spool based on the `chunk_size' and `edge` calculated before.\nsp_chunked_overlaped = sp.chunk(time=chunk_size, overlap=2*edge)\n\n# Process each patch in the spool and save the result patch\nfor patch in sp_chunked_overlap:\n    # Apply any pre-processing you may need (such as velocity to strain rate transformation, detrending, etc.)\n    # ...\n\n    # Apply the low-pass filter on the delta patch\n    pa_low_passed = patch.pass_filter(time=(None, cutoff_freq * filter_safety_factor))\n    # Resample the low-passed filter patch\n    new_time_ax = np.arange(pa_low_passed.attrs[\"time_min\"], pa_low_passed.attrs[\"time_max\"], np.timedelta64(dt, \"s\"))\n    pa_lfp = pa_low_passed.interolate(time=new_time_ax)\n    # Update processed patch's sampling interval \n    pa_lfp = pa_lfp.update_attrs(time_step=dt)\n\n    # Remove distorted edges from the data at both ends using the calculated `edge` value\n    pa_lfp_edgeless = pa_lfp.select(time=(edge, -edge), relative=True)\n\n    # Save processed patch \n    pa_lf_name = generate_file_name(pa_lfp_edgeless.attrs[\"time_min\"], pa_lfp_edgeless.attrs[\"time_max\"])\n    pa_lf_path = output_data_dir + pa_lf_name\n    pa_lfp_edgeless.io.write(pa_lf_path, \"dasdae\")\n```\n:::\n\n\n## Visualize the results\n\n::: {#74238721 .cell execution_count=5}\n``` {.python .cell-code}\n# Create a spool of LF processed results\nsp_lf = dc.spool(output_data_dir)\n\n# Merge the spool and create a single patch. May need to sub-select before merging to prevent exceeding the memory limit.\nsp_lf_merged = sp_lf.chunk(time=None)\npa_lf_merged = sp_lf_merged[0]\n\n# Visualize the results. Try different scale values for better Visualization.\npa_lf_merged.viz.waterfall(scale=0.1)\n```\n:::\n\n\n#### For any questions, please contact Ahmad Tourei: [GitHub Profile](https://github.com/ahmadtourei).\n\n",
    "supporting": [
      "low_freq_proc_files"
    ],
    "filters": [],
    "includes": {}
  }
}
